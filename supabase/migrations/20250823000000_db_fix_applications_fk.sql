-- PR db-fix: applications FK + table rename + messaging tables
-- Idempotent guards are included so this can be re-run safely.

-- 1) Rename gig_applications -> applications if needed
DO $$
BEGIN
  IF EXISTS (
    SELECT 1 FROM information_schema.tables
    WHERE table_schema='public' AND table_name='gig_applications'
  ) AND NOT EXISTS (
    SELECT 1 FROM information_schema.tables
    WHERE table_schema='public' AND table_name='applications'
  ) THEN
    EXECUTE 'ALTER TABLE public.gig_applications RENAME TO applications';
  END IF;
END$$;

-- 2) Ensure applications table exists (guard only)
CREATE TABLE IF NOT EXISTS public.applications (
  id          BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  gig_id      BIGINT,
  applicant   UUID,
  cover_letter TEXT,
  created_at  TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- 3) Align applications.gig_id type (to BIGINT), then add FK to gigs(id)
DO $$
BEGIN
  -- Make sure column exists
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_schema='public' AND table_name='applications' AND column_name='gig_id'
  ) THEN
    EXECUTE 'ALTER TABLE public.applications ADD COLUMN gig_id BIGINT';
  END IF;

  -- Force type to BIGINT if not already
  IF EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_schema='public' AND table_name='applications' AND column_name='gig_id' AND data_type <> 'bigint'
  ) THEN
    -- If table had UUIDs but no rows, this cast will work with USING NULL::bigint
    -- Safer pattern: drop any FK first (if present), then change type.
    BEGIN
      EXECUTE 'ALTER TABLE public.applications ALTER COLUMN gig_id TYPE BIGINT USING NULL::bigint';
    EXCEPTION WHEN others THEN
      -- Fallback: drop constraint if type-change blocked by FK
      BEGIN
        EXECUTE (
          SELECT 'ALTER TABLE public.applications DROP CONSTRAINT ' || quote_ident(tc.constraint_name)
          FROM information_schema.table_constraints tc
          WHERE tc.table_schema='public' AND tc.table_name='applications' AND tc.constraint_type='FOREIGN KEY'
          LIMIT 1
        );
      EXCEPTION WHEN others THEN
        -- ignore if no FK
      END;
      EXECUTE 'ALTER TABLE public.applications ALTER COLUMN gig_id TYPE BIGINT USING NULL::bigint';
    END;
  END IF;

  -- Add FK to gigs(id) if missing
  IF NOT EXISTS (
    SELECT 1
    FROM information_schema.table_constraints
    WHERE table_schema='public'
      AND table_name='applications'
      AND constraint_type='FOREIGN KEY'
  ) THEN
    EXECUTE 'ALTER TABLE public.applications
             ADD CONSTRAINT applications_gig_id_fkey
             FOREIGN KEY (gig_id) REFERENCES public.gigs(id) ON DELETE CASCADE';
  END IF;
END$$;

-- 4) Ensure applicant FK to auth.users(id) (optional but nice)
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.constraint_column_usage
    WHERE table_schema='public' AND table_name='applications' AND constraint_name='applications_applicant_fkey'
  ) THEN
    BEGIN
      EXECUTE 'ALTER TABLE public.applications
               ADD CONSTRAINT applications_applicant_fkey
               FOREIGN KEY (applicant) REFERENCES auth.users(id) ON DELETE SET NULL';
    EXCEPTION WHEN others THEN
      -- if auth schema not accessible in this environment, skip
      NULL;
    END;
  END IF;
END$$;

-- 5) Messaging primitives (if missing)
CREATE TABLE IF NOT EXISTS public.threads (
  id             BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  application_id BIGINT REFERENCES public.applications(id) ON DELETE CASCADE,
  created_at     TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE IF NOT EXISTS public.messages (
  id         BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  thread_id  BIGINT REFERENCES public.threads(id) ON DELETE CASCADE,
  sender     UUID,  -- auth.users.id
  body       TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE IF NOT EXISTS public.notifications (
  id         BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id    UUID, -- recipient
  type       TEXT,
  payload    JSONB,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- 6) Helpful indexes
CREATE INDEX IF NOT EXISTS idx_applications_gig_id ON public.applications(gig_id);
CREATE INDEX IF NOT EXISTS idx_threads_app_id     ON public.threads(application_id);
CREATE INDEX IF NOT EXISTS idx_messages_thread_id ON public.messages(thread_id);
CREATE INDEX IF NOT EXISTS idx_notifications_user ON public.notifications(user_id);
