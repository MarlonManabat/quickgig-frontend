create table if not exists public.gigs (
  id bigint generated by default as identity primary key,
  owner_id uuid not null references auth.users(id) on delete cascade,
  title text not null,
  description text not null,
  price numeric(12,2) not null check (price >= 0),
  tags text[] not null default '{}',
  is_remote boolean not null default true,
  location text,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);
create or replace function public.touch_gigs_updated_at() returns trigger
language plpgsql as $$ begin new.updated_at = now(); return new; end $$;
drop trigger if exists trg_gigs_updated_at on public.gigs;
create trigger trg_gigs_updated_at before update on public.gigs
for each row execute function public.touch_gigs_updated_at();
alter table public.gigs enable row level security;

drop policy if exists "gigs_read_public" on public.gigs;
create policy "gigs_read_public" on public.gigs for select using ( true );

drop policy if exists "gigs_owner_write" on public.gigs;
create policy "gigs_owner_write" on public.gigs
for insert with check ( owner_id = auth.uid() )
, for update using ( owner_id = auth.uid() )
, for delete using ( owner_id = auth.uid() );

create table if not exists public.applications (
  id bigint generated by default as identity primary key,
  gig_id bigint not null references public.gigs(id) on delete cascade,
  applicant_id uuid not null references auth.users(id) on delete cascade,
  status text not null default 'applied' check (status in ('applied','in_review','offered','hired','rejected')),
  message text,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  unique (gig_id, applicant_id)
);
create or replace function public.touch_applications_updated_at() returns trigger
language plpgsql as $$ begin new.updated_at = now(); return new; end $$;
drop trigger if exists trg_applications_updated_at on public.applications;
create trigger trg_applications_updated_at before update on public.applications
for each row execute function public.touch_applications_updated_at();
alter table public.applications enable row level security;

drop policy if exists "apps_applicant_read" on public.applications;
create policy "apps_applicant_read" on public.applications for select using ( applicant_id = auth.uid() );

drop policy if exists "apps_owner_read" on public.applications;
create policy "apps_owner_read" on public.applications for select using (
  exists (select 1 from public.gigs g where g.id = applications.gig_id and g.owner_id = auth.uid())
);

drop policy if exists "apps_insert_by_applicant" on public.applications;
create policy "apps_insert_by_applicant" on public.applications for insert with check ( applicant_id = auth.uid() );

drop policy if exists "apps_applicant_update_own" on public.applications;
create policy "apps_applicant_update_own" on public.applications for update using ( applicant_id = auth.uid() );

create table if not exists public.saved_gigs (
  user_id uuid not null references auth.users(id) on delete cascade,
  gig_id bigint not null references public.gigs(id) on delete cascade,
  created_at timestamptz not null default now(),
  primary key (user_id, gig_id)
);
alter table public.saved_gigs enable row level security;

drop policy if exists "saved_read_own" on public.saved_gigs;
create policy "saved_read_own" on public.saved_gigs for select using ( user_id = auth.uid() );

drop policy if exists "saved_write_own" on public.saved_gigs;
create policy "saved_write_own" on public.saved_gigs
for insert with check ( user_id = auth.uid() )
, for delete using ( user_id = auth.uid() );

drop policy if exists "apps_admin_read_all" on public.applications;
create policy "apps_admin_read_all" on public.applications
for select using ( exists (select 1 from public.profiles p where p.id=auth.uid() and p.is_admin) );
