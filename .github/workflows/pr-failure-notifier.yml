name: PR Failure Notifier
on:
  workflow_run:
    workflows: ["Release Check"]   # <-- keep in sync with your CI workflow name
    types: [completed]

jobs:
  notify-on-failure:
    if: github.event.workflow_run.conclusion == 'failure'
    runs-on: ubuntu-latest
    permissions:
      actions: read
      contents: read
      pull-requests: write
      issues: write
    steps:
      - name: Comment PR on failure with first error snippet
        uses: actions/github-script@v7
        with:
          script: |
            const run = context.payload.workflow_run;
            const { owner, repo } = context.repo;

            // Find the open PR for the head branch (works with forks)
            const headOwner = run.head_repository.owner.login;
            const headRef = `${headOwner}:${run.head_branch}`;
            const prs = await github.paginate(github.rest.pulls.list, {
              owner, repo, state: 'open', head: headRef
            });
            if (!prs.length) { core.info(`No open PR for ${headRef}`); return; }
            const pr = prs[0];

            // List jobs and pick failing ones
            const jobsResp = await github.paginate(
              github.rest.actions.listJobsForWorkflowRun,
              { owner, repo, run_id: run.id }
            );
            const jobs = jobsResp.jobs ?? [];
            const failing = jobs.filter(j => j.conclusion && j.conclusion !== 'success');

            // Attempt to fetch first failing job logs and extract a short snippet
            let snippet = '';
            let buildHint = false;
            if (failing.length) {
              try {
                const firstFail = failing[0];
                const resp = await github.request(
                  'GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs',
                  { owner, repo, job_id: firstFail.id }
                );
                const logUrl = resp.headers?.location ?? resp.url;
                const r = await fetch(logUrl, { headers: { 'User-Agent': 'github-script' } });
                const buf = Buffer.from(await r.arrayBuffer());
                const zlib = require('zlib');
                const text = zlib.gunzipSync(buf).toString('utf8');

                // First meaningful error line (with 2 lines of context)
                const lines = text.split(/\r?\n/);
                const idx = lines.findIndex(l =>
                  /(ERROR|Error|TypeError|ReferenceError|Module not found|Timeout)/.test(l)
                );
                if (idx >= 0) {
                  snippet = lines.slice(Math.max(0, idx - 2), idx + 3).join('\n').slice(0, 800);
                }
                const patterns = [
                  /Cannot find module '.*\.json'/,
                  /fs\.readFileSync is not a function/,
                  /Module not found: Can't resolve 'fs'/
                ];
                buildHint = patterns.some(p => p.test(snippet));
              } catch (e) {
                core.info(`Snippet extraction failed: ${e.message}`);
              }
            }

            let body = `ðŸ”´ **${run.name}** FAILED for \`${run.head_branch}\` @ \`${run.head_sha.slice(0,7)}\`.\n`;
            if (failing.length) {
              body += `\n**Failed job(s):**\n` + failing.map(j => `- ${j.name}`).join('\n');
            }
            if (snippet) {
              body += `\n\n**First error snippet:**\n\`\`\`\n${snippet}\n\`\`\``;
            }
            if (buildHint) {
              body += `\n\nPossible fix: move JSON to public/, enable resolveJsonModule in tsconfig, and replace fs usage with fetch.`;
            }
            body += `\n\n[View run logs](${run.html_url})`;

            await github.rest.issues.createComment({
              owner, repo, issue_number: pr.number, body
            });
